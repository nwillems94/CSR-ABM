---
title: "FlaringABM input leases"
author: "Nick Willems"
output:
  html_document:
    code_folding: hide
  pdf_document:
    keep_tex: true
knit: (function(input, ...) { rmarkdown::render(input, output_format='all', ...) })
---

```{css, echo=FALSE, eval=knitr::is_html_output()}
/* avoid displaying title and author in html output */
.title{
    display: none;
}
.author{
    display: none;
}
```

```{r, echo=FALSE, eval=knitr::is_latex_output()}
library(formatR)
knitr::opts_chunk$set(tidy=TRUE,
                    tidy.opts=list(width.cutoff=40),
                    fig.path=sub("/", "_tex/", knitr::opts_chunk$get('fig.path')))
```

```{r, echo=FALSE, include=FALSE}
library(knitr)
library(printr)
# define a method for objects of the class data.table
registerS3method("knit_print", "data.table", function(x, ...) {
    if (!shouldPrint(x)) {
        return(invisible())
    } else {
        NextMethod("knit_print") # print as data.frame
    }
})
```

GENERATE SAMPLE OIL AND GAS WELLS & LEASES FROM TEXAS RAILROAD COMMISSION DATA  

EACH WELL HAS THE FOLLOWING PROPERTIES  
  1. DEPTH  
  2. LOCATION  
      - Lat & Lon  
      - Area  
  3. COMPLETION DATE  

EACH LEASE HAS THE FOLLOWING PROPERTIES  
  1. AVERAGE MONTHLY OIL PRODUCTION OVER THE STUDY PERIOD  
      - Marketable production (`oil_avg`)  
      - Total production (`total_oil_avg`)  
  2. AVERAGE MONTHLY GAS PRODUCTION OVER THE STUDY PERIOD  
      - Marketable production (`gas_avg`, `csgd_avg`)  
      - Total production of gas or casinghead gas (`total_MCF_avg`)  
      - Flared gas or casinghead gas (`flared_MCF_avg`)  
  3. LOCATION  
      - Lat & Lon  
      - Area  
  4. DISTANCE FROM INFRASTRUCTURE  
      - Crude pipelines  
      - Gas processing facilities  

  Well data is used to find approximate lease locations and to calculate capital expenditures based on well depth(s). 
  Cost parameters are derived during initialization by matching leases to areas and sampling data from: 
  [US EIA. (2016)](zotero://select/items/0_EJYISQT4).  

```{r}
library(readxl)
library(data.table)
library(sf)
library(maps)
```

******  

## Production Data Query Dump {#pdq}
 [Source](https://mft.rrc.texas.gov/link/fe3298a2-8788-4234-b2a0-90ee41558d75),
 [Manual](https://www.rrc.texas.gov/media/50ypu2cg/pdq-dump-user-manual.pdf)

> This is a complete dump of the Production Data and Historical Ledger databases 
> and includes production from 1993 to current. The file is updated once monthly 
> and is delivered via cloud service.  

******  

# Import spatial data
 [Source: Play boundaries](https://www.eia.gov/maps/maps.htm), 
 [Source: Processing plants & crude pipelines](https://www.eia.gov/maps/layer_info-m.php)
```{r, render=knitr::normal_print}
TX <- st_as_sf(map("state", regions="Texas", plot=FALSE, fill=TRUE))
names(TX)[names(TX)=="geom"] <- "geometry"
st_geometry(TX) <- "geometry"

head(TX)
plot(TX$geometry, reset=FALSE, main="Gas plants and crude oil pipelines in Texas")

permian     <- st_read("./data/spatial/PermianBasin_Boundary_Structural_Tectonic",
                        layer="Permian_SubBasins_201712", quiet=TRUE)
head(permian)
spraberry   <- st_read("./data/spatial/ShalePlays_AboYeso_GlorietaYeso_Spraberry_EIA",
                        layer="ShalePlay_Spraberry_Boundary_EIA_Aug2015_v2", quiet=TRUE)
head(spraberry)
eagle_ford  <- st_read("./data/spatial/EagleFord_Play_Boundary_Elevation_Isopach_EIA",
                        layer="ShalePlay_EagleFord_Boundary_EIA_Aug2015_v2", quiet=TRUE)
head(eagle_ford)

# merge permian and eagle_ford shapefiles
TX <- st_transform(TX, st_crs(permian))
cat("CRS ok:", (st_crs(permian) == st_crs(TX)), "\n")
cat("CRS ok:", (st_crs(permian) == st_crs(spraberry)) & (st_crs(permian) == st_crs(eagle_ford)), "\n")
permian$geometry <- st_difference(permian$geometry, spraberry$geometry)
areas <- rbind(cbind("Name"="Eagle Ford", eagle_ford[, c("Area_sq_mi", "Area_sq_km")]),
                cbind("Name"="Spraberry", spraberry[, c("Area_sq_mi", "Area_sq_km")]),
                permian[permian$Name %in% c("Delaware Basin", "Midland Basin"), c("Name", "Area_sq_mi", "Area_sq_km")])

plot(areas$geometry, col=rainbow(4, alpha=0.5), add=TRUE)
legend('bottomleft', areas$Name, fill=rainbow(4, alpha=0.5))

# gas processing plants
gas_plants <- st_read("./data/spatial/NaturalGas_ProcessingPlants_US_EIA",
                        layer="NaturalGas_ProcessingPlants_US_2017_v2", quiet=TRUE)
head(gas_plants)
plot(gas_plants$geometry, col="orange", pch="+", cex=1.5, add=TRUE)

# crude oil pipelines
crude_pipelines <- st_read("./data/spatial/CrudeOil_Pipelines_US_EIA",
                            layer="CrudeOil_Pipelines_US_202001", quiet=TRUE)
head(crude_pipelines)
plot(crude_pipelines$geometry, col="darkgrey", add=TRUE)

# store list of shapefiles
cat("CRS ok:", (st_crs(permian) == st_crs(crude_pipelines)) & (st_crs(permian) == st_crs(gas_plants)), "\n")
spatial_data <- list("state"=TX, "areas"= areas,
                    "gas_plants"= gas_plants[gas_plants$State %in% c("LA","NM","OK","TX"),],
                    "crude_pipelines"= crude_pipelines)

rm(TX, permian, spraberry, eagle_ford, areas, gas_plants, crude_pipelines)
```

******  

# Process Wellbores  
Identify locations, depths, and completion date of wellbores to subsequently merge into the lease production data  

## Wellbore Completion data  
Contains lease numbers ([PDQ](#pdq))
```{r}
OG_WELL <- fread("unzip -p ./data/PDQ_DSV.zip OG_WELL_COMPLETION_DATA_TABLE.dsv", sep="}",
                select=list(character=c("COUNTY_NAME", "OIL_GAS_CODE", "DISTRICT_NO", "LEASE_NO",
                            "API_COUNTY_CODE", "API_UNIQUE_NO", "WELL_NO")))
OG_WELL[, "API_NO":= paste0(API_COUNTY_CODE, API_UNIQUE_NO)]
```

## Full Wellbore  
Contains lat/lon & depth 
 [Source](https://mft.rrc.texas.gov/link/9ef1955f-cf26-4bd4-8030-1253eb772cf9),
 [Manual](https://www.rrc.texas.gov/media/cx2i4xrm/wba091_well-bore-database.pdf)
```{r}
wellbore_full <- fread("./data/dbf900.txt.gz", sep="\n", header=FALSE)

# find unique wellbores (including API number) and assign parent record id
wellbore_full[, "id":= nafill(ifelse(grepl("^01", V1), .I, NA), type="locf")]
```

Find location information
```{r}
unique_locs <- wellbore_full[, grep("^13", V1)]
cat(wellbore_full[, 100 * uniqueN(id[unique_locs]) / uniqueN(id)], "% of 'full' wellbores have lat/lon data\n")

unique_bors <- wellbore_full[unique_locs, id]
```

In the single case where there is a duplicate, the first location is the correct one
 (based on [searching](http://webapps2.rrc.texas.gov/EWA/wellboreQueryAction.do) the well by API
 and cross checking the county number with lat/lon data)
```{r}
cat(sum(duplicated(unique_bors)), "duplicate location record(s).",
    "Including id(s):", unique_bors[duplicated(unique_bors)],"\n")
unique_locs <- unique_locs[!duplicated(unique_bors)]
unique_bors <- unique_bors[!duplicated(unique_bors)]
```

Extract relevant wellbore data from hierarchical records
```{r}
wellbore_data <- wellbore_full[sort(c(unique_bors, unique_locs)),
                                # API number, depth, and completion date from record 01
                                .("API_NO"= substr(V1[1], 3, 10), "depth"= substr(V1[1], 29, 33),
                                "start"= substr(V1[1], 21, 26),
                                # location lat/lon from record 13
                                "lat"= substr(V1[2], 133, 141), "lon"= substr(V1[2], 143, 151)), by=id]

wellbore_data[, "lat":=  as.numeric(gsub("(\\d{3})(\\d{6})", "\\1.\\2", lat))]
wellbore_data[, "lon":= -as.numeric(gsub("(\\d{3})(\\d{6})", "\\1.\\2", lon))]
wellbore_data[, "depth":= as.numeric(depth)]
wellbore_data[, "start":= as.numeric(start)]
wellbore_data[start<150000, "start":= NA_integer_]
```

Get missing start dates from WB-DATE segment
```{r}
wellbore_data[
    wellbore_full[wellbore_data[is.na(start)], on="id"][
        grepl("^03", V1), .(as.numeric(substring(V1, c(40,48), c(45,53)))), by=id][V1>0, min(V1), by=id],
    on="id", "start":= V1]
```

Well depth information in WB-OVERRIDE-BONDED-DEPTH, WB-TOTAL-BONDED-DEPTH
```{r, eval=FALSE}
# NOT RUN
wellbore_data[wellbore_full[unique_bors][nchar(V1)>=157], on="id",
            "depth":= if (depth==0) as.numeric(substring(V1, 152, 157)), by=.EACHI]
wellbore_data[wellbore_full[unique_bors], on="id",
            "depth":= if (depth==0) as.numeric(substring(V1, 133, 138)), by=.EACHI]
```

Well depth from formation segement WB-FORMATION-DEPTH
```{r, eval=FALSE}
# NOT RUN
unique_form <- wellbore_full[, .I[(nchar(V1)>=42) & (id %in% wellbore_data[depth==0]$id) & grepl("^09", V1)]]
wellbore_data[wellbore_full[unique_form, max(as.numeric(substring(V1, 38, 42))), by=id], on="id", "depth":= V1]
```

## Permit  
Contains well type & depth
 [Source](https://mft.rrc.texas.gov/link/91a36fea-4dad-4f26-96c3-30843d0e0315),
 [Manual](https://www.rrc.texas.gov/media/ezxjqdmn/oga049.pdf)
```{r}
well_permits <- fread("./data/daf804.txt.gz", sep="\n", header=FALSE)

# identify unique entries
well_permits[, "ID":= .I]
well_permits[, "sequence_no":= substr(V1, 10, 11), by=ID]
well_permits[, "API_NO":= substr(V1, 503, 510), by=ID]

# is this a horizontal well?
# well_permits[, "horizontal":= any(substring(V1, c(482, 494), c(482, 494)) == "Y"), by=ID]
well_permits[, "horizontal":= (substr(V1, 482, 482) == "Y"), by=ID]
well_permits[, "horizontal":= horizontal[which.min(sequence_no)], by=API_NO]

wellbore_data[well_permits[horizontal==TRUE, .("API_NO"=unique(API_NO))], on="API_NO", "horizontal":= TRUE]
wellbore_data[is.na(horizontal), "horizontal":= FALSE]

# get missing well depths
well_permits[, "depth":= as.numeric(substr(V1, 55, 59)), by=ID]
wellbore_data[well_permits[depth>0, depth[which.min(sequence_no)], by=API_NO], on="API_NO",
            "depth":= if (depth==0) V1, by=.EACHI]
rm(well_permits)
```

Drop suspicious locations, outlier depths, and wells drilled outside of study period relevance
```{r}
wellbore_data[lat==0 | lon==0, c("lat","lon"):= NA]
wellbore_data[depth==0 | !(depth %between% quantile(depth[depth>0], c(0.01, 0.99))), "depth":= NA]
wellbore_data[!between(start, 196301, 201909), c("lat","lon","depth"):= NA]
```

Estimate completion cost based on wellbore depth in meters ([Lukawski et al. 2014](zotero://select/items/0_KHRCUE96))
```{r, eval=FALSE}
# NOT RUN
wellbore_data[, "DC_cost":= (1.65e-5)*(depth/3.28084)^1.607]
```

Merge locations & depth information into full well record
```{r}
OG_WELL[wellbore_data, on="API_NO", c("start","lat","lon","depth","horizontal"):= .(start, lat, lon, depth, horizontal)]

cat("Matched", OG_WELL[, 100*sum(!is.na(lat))/.N], "% of wells with lat/lon positions\n")
cat("Matched", OG_WELL[, 100*sum(!is.na(depth))/.N], "% of wells with depths\n")

rm(wellbore_full)
rm(wellbore_data)
```

## Map wells to areas
```{r}
OG_WELL[!is.na(lat), "area":= st_join(st_as_sf(.SD, coords=c("lon","lat"), crs=st_crs(spatial_data$area)),
                                        spatial_data$area, join=st_within)$Name]

# remove duplicate entries
OG_WELL[OG_WELL[, duplicated(.SD[, -"WELL_NO"])], "area":= NA]

plot(spatial_data$state$geometry, reset=FALSE, main="Well locations")
plot(spatial_data$areas$geometry, col=rainbow(4, alpha=0.3), add=TRUE)
legend("bottomleft", spatial_data$areas$Name, fill=rainbow(4, alpha=0.3))
OG_WELL[!is.na(area) & !is.na(depth), plot(st_as_sf(.SD, coords=c("lon","lat"), crs=st_crs(spatial_data$area))$geometry,
                                        col=rainbow(4)[factor(area, levels=spatial_data$areas$Name)], pch=4, add=TRUE)]
```

## Check for multilateral wells and multi-well pads
Multilaterals with completion dates less than a year apart
```{r}
OG_WELL[!is.na(area),
        "stacked":= if((uniqueN(API_NO) > 1) & (max(start)-min(start) <= 100)) API_NO[which.min(start)],
        by=.(lat, lon, OIL_GAS_CODE)]
OG_WELL[!is.na(area) & is.na(stacked),
        "stacked":= if((uniqueN(API_NO) > 1) & (max(start)-min(start) <= 100)) API_NO[which.min(start)],
        by=.(round(lat, 5), round(lon, 5), OIL_GAS_CODE)]
OG_WELL[!is.na(area) & is.na(stacked),
        "stacked":= if((uniqueN(API_NO) > 1) & (max(start)-min(start) <= 100)) API_NO[which.min(start)],
        by=.(trunc(lat*10^5)/10^5, trunc(lon*10^5)/10^5, OIL_GAS_CODE)]
cat("Identified",  OG_WELL[, 100 * sum(!is.na(stacked)) / .N], "% of wells which are actually stacked multilaterals")
```

Identify wells which are close enough together to share a wellpad [~1320 ft](zotero://select/items/0_EJYISQT4)
```{r}
OG_WELL[!is.na(area) & !duplicated(API_NO),
        # find clusters, approximating distance by treating earth as a sphere with radius 40,075 km
        "shared":= cutree(hclust(dist((40075/360)*.SD[, .(lat, lon*cos(lat*pi/180))]),
                            method="complete"), h=1320/3.281/1000),
        by=.(area, DISTRICT_NO)]

OG_WELL[OG_WELL[!is.na(shared), .N, by=.(shared, area, DISTRICT_NO)],
            on=c("shared", "area", "DISTRICT_NO"), "shared":= N]
OG_WELL[is.na(shared), "shared":= 1]
```

```{r, results='hide'}
OG_WELL[!duplicated(API_NO), 100 * sum(shared>1, na.rm=TRUE) / .N, by=.("year"=as.numeric(substr(start, 1, 4)))][,
        {plot(year, V1, main="Percent of wells on shared well pads", xlab="Year", ylab="% of total"); NULL}]
```

```{r, fig.width=7, fig.height=4, results='hide', fig.align='center'}
OG_WELL[!duplicated(API_NO) & (area %in% c("Midland Basin", "Spraberry", "Delaware Basin")),
        .(mean(shared[area=="Delaware Basin"]), mean(shared[area %in% c("Midland Basin", "Spraberry")])),
        keyby=.("year"= as.numeric(substr(start, 1, 4)))][between(year, 2011, 2020),
        {plot(0, 0, xlim=c(2011,2019), ylim=c(0,6), yaxt='n', yaxs='i', lab=c(9,7,7), bty='n',
            main="Estimated average well count per drilling rig", xlab="Year", ylab="Wells per pad");
        axis(2, tick=FALSE, las=2, hadj=0); abline(h=1:6, col="grey");
        matplot(year, .SD[,-1], type='b', col=rainbow(4)[3:4], pch=19, lty=1, lwd=2, add=TRUE);
        legend("topleft", inset=0.05, legend=c("Delaware Basin", "Midland Basin"), col=rainbow(4)[3:4], pch=19); NULL}]
```

```{r, echo=FALSE, fig.width=6, fig.height=4, fig.align='center'}
image <- "https://www.eia.gov/todayinenergy/images/2021.10.19/chart3.svg"
if (knitr::is_latex_output())  {
    output <- paste0(knitr::opts_chunk$get("fig.path"), "EIA_multiwell.pdf")
    rsvg_pdf(image, output, width=knitr::opts_current$get("out.width.px"))
    knitr::include_graphics(output)
} else {
    knitr::include_graphics(image)
}
```

[EIA plot based on Enverusa data](https://www.eia.gov/todayinenergy/detail.php?id=50016)

******  

# Lease data  
## Historical Disposition by Lease  
Includes (flared) gas volumes ([PDQ](#pdq))
[TxRRC](http://webapps2.rrc.texas.gov/EWA/help/prod_results_questions.html):  

> "Disposition details provide the breakdown of the various ways oil or gas leases dispose of their products...
> ...The disposition totals may not match the production totals because leases may have stock on hand at the
> beginning of the month. All production must be reported regardless of disposition. Disposition is shown for the
> month in which it was actually moved."

Using disposition instead of production (e.g., LEASE_OIL_PROD_VOL) ensures 
consistency with flaring volumes and volumes moved by pipeline, rail, or truck  
```{r}
OG_LEASE_CYCLE_DISP <- fread("unzip -p ./data/PDQ_DSV.zip OG_LEASE_CYCLE_DISP_DATA_TABLE.dsv", sep="}", quote="",
                            select=list(factor=c("DISTRICT_NO","FIELD_NO","OPERATOR_NO","LEASE_NO","OIL_GAS_CODE"),
                                        character=c("FIELD_NAME"),
                                        numeric=c("CYCLE_YEAR_MONTH"),
                                        numeric=sprintf("LEASE_OIL_DISPCD%02d_VOL",   c(0:9, 99)),
                                        numeric=sprintf("LEASE_COND_DISPCD%02d_VOL",  c(0:8, 99)),
                                        numeric=sprintf("LEASE_GAS_DISPCD%02d_VOL",   c(1:9, 99)),
                                        numeric=sprintf("LEASE_CSGD_DISPCDE%02d_VOL", c(1:8, 99))))

# marketable production
OG_LEASE_CYCLE_DISP[, "oil_BBL":=  rowSums(.SD), .SDcols=sprintf("LEASE_OIL_DISPCD%02d_VOL",    0:2)]
OG_LEASE_CYCLE_DISP[, "cond_BBL":= rowSums(.SD), .SDcols=sprintf("LEASE_COND_DISPCD%02d_VOL",   0:2)]
OG_LEASE_CYCLE_DISP[, "gas_MCF":=  rowSums(.SD), .SDcols=sprintf("LEASE_GAS_DISPCD%02d_VOL",  c(2:4, 7:8, 99))]
OG_LEASE_CYCLE_DISP[, "csgd_MCF":= rowSums(.SD), .SDcols=sprintf("LEASE_CSGD_DISPCDE%02d_VOL", c(2:4, 7:8, 99))]

# total production
OG_LEASE_CYCLE_DISP[, "total_oil_BBL":= rowSums(.SD), .SDcols=patterns("OIL_DISPCD")]
OG_LEASE_CYCLE_DISP[, "total_MCF":=     rowSums(.SD), .SDcols=patterns("GAS_DISPCD|CSGD_DISPCD")]
OG_LEASE_CYCLE_DISP[, "total_BOE":= total_oil_BBL + cond_BBL + total_MCF/6]

OG_LEASE_CYCLE_DISP[, "flared_MCF":= LEASE_GAS_DISPCD04_VOL + LEASE_CSGD_DISPCDE04_VOL]
```

```{r, results='hide'}
OG_LEASE_CYCLE_DISP[, sum(flared_MCF) / sum(oil_BBL+cond_BBL), by=.(OPERATOR_NO, CYCLE_YEAR_MONTH)][
    CYCLE_YEAR_MONTH>201000,
    {"h_data"= hist(log(V1), plot=FALSE);
    plot(exp(h_data$mids), h_data$density, log='x', type='h', lwd=10, lend=2,
    main="Distribution of operator flaring intensity", xlab="Flaring intensity (MCF/BBL)", ylab="Density"); NULL}]
```

```{r}
# Lease, district numbers are unique
sum(duplicated(OG_LEASE_CYCLE_DISP, by=c("DISTRICT_NO", "LEASE_NO", "CYCLE_YEAR_MONTH")))

# Most OIL leases have at least some associated gas
summary(OG_LEASE_CYCLE_DISP[OIL_GAS_CODE=="O", sum(csgd_MCF), by=.(DISTRICT_NO, LEASE_NO)]$V1)

# There is only casinghead gas in OIL leases
summary(OG_LEASE_CYCLE_DISP[OIL_GAS_CODE=="O", sum(gas_MCF), by=.(DISTRICT_NO, LEASE_NO)]$V1)

# There is no casinghead gas disposition in GAS leases
summary(OG_LEASE_CYCLE_DISP[OIL_GAS_CODE=="G", sum(csgd_MCF), by=.(DISTRICT_NO, LEASE_NO)]$V1)

# Condensate is only report in GAS leases
OG_LEASE_CYCLE_DISP[, sum(cond_BBL), by=.(DISTRICT_NO, LEASE_NO, OIL_GAS_CODE)][,
                            as.list(summary(V1)), by=OIL_GAS_CODE]

# Condensate accounts for a relatively small proportion of BOE
summary(OG_LEASE_CYCLE_DISP[gas_MCF > 0, cond_BBL / (gas_MCF/6)])

# GAS leases have no oil disposition:
summary(OG_LEASE_CYCLE_DISP[OIL_GAS_CODE=="G", sum(oil_BBL), by=.(DISTRICT_NO, LEASE_NO)]$V1)

# and the proportion of gas flared in GAS leases is almost always zero:
OG_LEASE_CYCLE_DISP[OIL_GAS_CODE=="G", as.list(summary(flared_MCF/gas_MCF)),
                            keyby=substr(CYCLE_YEAR_MONTH,0,4)]
```

Identify leases of interest  
```{r}
OG_IDS <- OG_LEASE_CYCLE_DISP[DISTRICT_NO %in% sprintf("%02d", c(1:4, 9:11))][,
                            .("start"= min(CYCLE_YEAR_MONTH), "expiration"= max(CYCLE_YEAR_MONTH), "N"= .N),
                            by=.(LEASE_NO, FIELD_NO, FIELD_NAME, DISTRICT_NO, OIL_GAS_CODE)]

# use the earliest well completion date to estimate start of lease lifetime
OG_IDS[OG_WELL[!is.na(area) & !is.na(depth) & !is.na(start), min(start), by=.(DISTRICT_NO, LEASE_NO)],
                on=c("DISTRICT_NO", "LEASE_NO"), "start":= pmin(V1, start)]
OG_IDS[, "lifetime":= .SD[, lapply(.(start, expiration), function(x) 12*trunc(x/100) + x %% 100)][, 1+V2-V1]]
```

Lease numbers can change over time. Where possible, back propagate new lease numbers to historic years  
```{r}
# identify leases with changing identifiers and consolidate production from stacked wells
OG_IDS[OG_WELL[, if(uniqueN(LEASE_NO)>1) .SD, by=.("API"=fcoalesce(stacked, API_NO))][,
                .("API_NOs"=.(unique(API))), by=.(DISTRICT_NO, LEASE_NO)],
        on=c("DISTRICT_NO", "LEASE_NO"), "API_NOs":= API_NOs]
OG_IDS[, "size":= lengths(API_NOs)]

# propogate lease aliases
setorder(OG_IDS, -start)

# determine the most recent LEASE_NO and propogate backwards
OG_IDS[size==1,
    "alias":= {API=unlist(API_NOs); LEASE_NO[match(API, API)]}, by=DISTRICT_NO]
OG_IDS[size>1,
    "alias":= .(sapply(API_NOs, function(x) LEASE_NO[which(sapply(API_NOs, setequal, x))[1]])), by=.(size, DISTRICT_NO)]
OG_IDS[size>=1, "drop":= FALSE]
```

Drop certain leases  
```{r}
# drop incomplete sets of leases as indicated by the well records
OG_IDS[OG_IDS[size>0, unlist(API_NOs), by=.(DISTRICT_NO, LEASE_NO)][, if(.N==1) .SD, by=V1],
        on=c("DISTRICT_NO", "LEASE_NO"), "drop":= TRUE]
# drop leases which don't map neatly to an alias (likely the number of member wells is different)
OG_IDS[!is.na(alias), "drop":= if(.N == 1) TRUE, by=.(DISTRICT_NO, alias)]
# drop leases where alias does not cover all well instances
OG_IDS[OG_IDS[drop==FALSE, unlist(API_NOs), by=.(DISTRICT_NO, LEASE_NO, alias)][, if(uniqueN(alias)>1) .SD, by=V1],
            on=c("DISTRICT_NO","LEASE_NO"), "drop":= TRUE]

# drop leases which have more missing data than entries
OG_IDS[!is.na(alias), "drop":= if((sum(N) / sum(lifetime)) < 0.5) TRUE, by=.(alias, DISTRICT_NO)]
OG_IDS[is.na(alias) & ((N / lifetime) < 0.5), "drop":= TRUE]

# drop leases which started operating too close to the end of the data period
OG_IDS[!is.na(alias), "drop":= if(min(start) > 201910) TRUE, by=.(alias, DISTRICT_NO)]
OG_IDS[is.na(alias) & (start > 201910), "drop":= TRUE]

# drop leases that stopped operating before 2010
OG_IDS[!is.na(alias), "drop":= if(max(expiration) < 201001) TRUE, by=.(alias, DISTRICT_NO)]
OG_IDS[is.na(alias) & (expiration < 201001), "drop":= TRUE]

# drop leases that changed from oil to gas (or vice versa)
OG_IDS[!is.na(alias), "drop":= if(uniqueN(OIL_GAS_CODE) > 1) TRUE, by=.(DISTRICT_NO, alias)]

# drop all occurences of dropped alias
OG_IDS[!is.na(alias), "drop":= if(sum(drop, na.rm=TRUE) > 1) TRUE, by=.(DISTRICT_NO, alias)]

# leases whose identifiers never changed are their own alias
OG_IDS[is.na(alias), "alias":= LEASE_NO]
```
Apply aliases to wells
```{r}
OG_WELL[OG_IDS[(is.na(drop) | drop==FALSE)], on=c("DISTRICT_NO", "LEASE_NO"), "alias":= alias]
```
## Combine with well (location) data  
```{r, dev.args=list(bg='transparent')}
# extract location from field names
OG_WELL[OG_IDS[grepl("spraberry", tolower(FIELD_NAME))], on=c("DISTRICT_NO","LEASE_NO"),
        "area":= replace(area, !is.na(lat), "Spraberry")]
OG_WELL[OG_IDS[grepl("midland", tolower(FIELD_NAME))], on=c("DISTRICT_NO","LEASE_NO"),
        "area":= replace(area, !is.na(lat), "Midland Basin")]
OG_WELL[OG_IDS[grepl("delaware", tolower(FIELD_NAME))], on=c("DISTRICT_NO","LEASE_NO"),
        "area":= replace(area, !is.na(lat), "Delaware Basin")]
OG_WELL[OG_IDS[grepl("eagle ford", tolower(FIELD_NAME))], on=c("DISTRICT_NO","LEASE_NO"),
        "area":= replace(area, !is.na(lat), "Eagle Ford")]

OG_IDS[ # aggregate by district & lease
        OG_WELL[!is.na(area) & !is.na(depth), .(mean(lat), mean(lon),
                names(sort(-table(area)))[1], names(sort(-table(COUNTY_NAME)))[1]), by=.(DISTRICT_NO, LEASE_NO)],
        on=c("DISTRICT_NO", "LEASE_NO"), c("lat", "lon", "area", "county"):= .(V1, V2, V3, V4)]
cat("Matched", OG_IDS[!is.na(lat), .N], "leases with wells & locations in Eagle Ford & Permian basins")

# drop leases without location information
OG_IDS[is.na(lat), "drop":= TRUE]

plot(spatial_data$state$geometry, reset=FALSE, main="Approximate lease locations")
plot(spatial_data$areas$geometry, col=rainbow(4, alpha=0.3), add=TRUE)
legend("bottomleft", spatial_data$areas$Name, fill=rainbow(4, alpha=0.3))
OG_IDS[!is.na(area), plot(st_as_sf(.SD, coords=c("lon","lat"), crs=st_crs(spatial_data$area))$geometry,
                            col=rainbow(4)[factor(area, levels=spatial_data$areas$Name)], pch=4, add=TRUE)]
```

### Output complete well records
```{r}
fwrite(OG_WELL[!is.na(area) & !is.na(depth)], file="./processed/wells.csv")
rm(OG_WELL)
```

```{r, results='hide'}
plot(0, type="n", xlim=c(0, 1), ylim=c(0, 1),
    main="Oil lease production profiles", xlab="Scaled time", ylab="Scaled oil production [BBL]")
OG_LEASE_CYCLE_DISP[OG_IDS[(is.na(drop) | drop==FALSE) & (OIL_GAS_CODE=="O") & (expiration<201912)],
    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][,
        sum(total_oil_BBL), by=.(DISTRICT_NO, alias, CYCLE_YEAR_MONTH)][,
        {"time"= .SD[, .(12*trunc(CYCLE_YEAR_MONTH/100) + CYCLE_YEAR_MONTH %% 100)][, V1-min(V1)];
        lines(time/max(time), V1/max(V1), col=adjustcolor("black", 0.025)); NULL}, by=.(DISTRICT_NO, alias)]

plot(0, type="n", xlim=c(0, 1), ylim=c(0, 1),
    main="Oil lease production profiles", xlab="Scaled time", ylab="Scaled casinghead gas production [MCF]")
OG_LEASE_CYCLE_DISP[OG_IDS[(is.na(drop) | drop==FALSE) & (OIL_GAS_CODE=="O") & (expiration<201912)],
    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][,
        sum(total_MCF), by=.(DISTRICT_NO, alias, CYCLE_YEAR_MONTH)][,
        {"time"= .SD[, .(12*trunc(CYCLE_YEAR_MONTH/100) + CYCLE_YEAR_MONTH %% 100)][, V1-min(V1)];
        lines(time/max(time), V1/max(V1), col=adjustcolor("black", 0.025)); NULL}, by=.(DISTRICT_NO, alias)]

plot(0, type="n", xlim=c(0, 1), ylim=c(0, 1),
    main="Gas lease production profiles", xlab="Scaled time", ylab="Scaled gas production [MCF]")
OG_LEASE_CYCLE_DISP[OG_IDS[(is.na(drop) | drop==FALSE) & (OIL_GAS_CODE=="G") & (expiration<201912)],
    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][,
        sum(total_MCF), by=.(DISTRICT_NO, alias, CYCLE_YEAR_MONTH)][,
        {"time"= .SD[, .(12*trunc(CYCLE_YEAR_MONTH/100) + CYCLE_YEAR_MONTH %% 100)][, V1-min(V1)];
        lines(time/max(time), V1/max(V1), col=adjustcolor("black", 0.025)); NULL}, by=.(DISTRICT_NO, alias)]

plot(0, type="n", xlim=c(0, 1), ylim=c(0, 1),
    main="Gas lease production profiles", xlab="Scaled time", ylab="Scaled condensate production [BBL]")
OG_LEASE_CYCLE_DISP[OG_IDS[(is.na(drop) | drop==FALSE) & (OIL_GAS_CODE=="G") & (expiration<201912)],
    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][,
        sum(cond_BBL), by=.(DISTRICT_NO, alias, CYCLE_YEAR_MONTH)][,
        {"time"= .SD[, .(12*trunc(CYCLE_YEAR_MONTH/100) + CYCLE_YEAR_MONTH %% 100)][, V1-min(V1)];
        lines(time/max(time), V1/max(V1), col=adjustcolor("black", 0.025)); NULL}, by=.(DISTRICT_NO, alias)]

plot(0, type="n", xlim=c(0, 1), ylim=c(0, 1),
    main="Lease production profiles", xlab="Scaled time", ylab="Scaled total production [BOE]")
OG_LEASE_CYCLE_DISP[OG_IDS[(is.na(drop) | drop==FALSE) & (expiration<201912)],
    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][,
        sum(total_BOE), by=.(DISTRICT_NO, alias, CYCLE_YEAR_MONTH)][,
        {"time"= .SD[, .(12*trunc(CYCLE_YEAR_MONTH/100) + CYCLE_YEAR_MONTH %% 100)][, V1-min(V1)];
        lines(time/max(time), V1/max(V1), col=adjustcolor("black", 0.025)); NULL}, by=.(DISTRICT_NO, alias)]
```

## Summarize lease production  
Average production characteristics of leases from 2010 onward  
```{r, render=knitr::normal_print}
OG_LEASE_AVG <- OG_LEASE_CYCLE_DISP[OG_IDS[is.na(drop) | drop==FALSE],
                                    on=c("LEASE_NO", "DISTRICT_NO", "FIELD_NO", "OIL_GAS_CODE")][
                                    order(CYCLE_YEAR_MONTH),
                                    c("OPERATOR_NO"= ifelse(uniqueN(OPERATOR_NO)==1, first(OPERATOR_NO), NA_integer_),
                                    "start"= min(start), "expiration"= max(expiration),
                                    "area"= first(area), "county"= first(county), "lat"= first(lat), "lon"= first(lon),
                                    # "Estimated Ultimate Recovery" from emprical distribution
                                    .SD[, sum(total_BOE), keyby=CYCLE_YEAR_MONTH][CYCLE_YEAR_MONTH>=max(start)][
                                    between(CYCLE_YEAR_MONTH, CYCLE_YEAR_MONTH[which.max(V1)], 201912),
                                        #   time of peak production
                                        c("t_i"= CYCLE_YEAR_MONTH[1],
                                        #   initial (peak) Production and decline
                                        "q_i"= V1[1],
                                        "qdel_i"= mean((V1[1] - V1[2:4]) / 1:3, na.rm=TRUE),
                                        "q_fit"= sum(V1))],
                                    #   total Quantity produced prior to the time window
                                    .SD[CYCLE_YEAR_MONTH<201001,
                                        c("qcum_0_BBL"= sum(total_oil_BBL+cond_BBL),
                                          "qcum_0_MCF"= sum(total_MCF))] +
                                    # back-cast constant production before start of reporting
                                        diff(sapply(.(min(start), 199301),
                                                function(x) 12*trunc(x/100) + x %% 100)) *
                                            .SD[CYCLE_YEAR_MONTH==199301,
                                            c(sum(total_oil_BBL+cond_BBL), sum(total_MCF))],
                                    #   total Quantity produced during time window
                                    .SD[between(CYCLE_YEAR_MONTH, 201001, 201912),
                                        c("qcum_i_BBL"= sum(total_oil_BBL+cond_BBL),
                                          "qcum_i_MCF"= sum(total_MCF))],
                                    lapply(.SD[between(CYCLE_YEAR_MONTH, 201001, 201912),
                                                c("oil_BBL","cond_BBL","gas_MCF","csgd_MCF",
                                                "total_BOE", "total_oil_BBL","total_MCF","flared_MCF",
                                                # fraction of oil transported by pipeline, rail, & truck
                                                sprintf("LEASE_OIL_DISPCD%02d_VOL", 0:2))] /
                                                uniqueN(CYCLE_YEAR_MONTH[between(CYCLE_YEAR_MONTH, 201001, 201912)]),
                                            sum, na.rm=TRUE)),
                                    by=.("LEASE_NO"= alias, DISTRICT_NO, OIL_GAS_CODE)]

setnames(OG_LEASE_AVG, c("oil_BBL","cond_BBL","gas_MCF","csgd_MCF","total_oil_BBL","total_MCF","flared_MCF"),
                    c("oil_avg","cond_avg","gas_avg","csgd_avg","total_oil_avg","total_MCF_avg","flared_MCF_avg"))

rm(OG_IDS)
rm(OG_LEASE_CYCLE_DISP)
head(OG_LEASE_AVG)
```

Calculate how oil leaves the lease (disposition)  
```{r}
OG_LEASE_AVG[OIL_GAS_CODE=="O", sprintf("%s_frac", c("pipe","rail","truck")):= .SD / oil_avg,
                        .SDcols=sprintf("LEASE_OIL_DISPCD%02d_VOL", 0:2)]

# drop unused columns
OG_LEASE_AVG[, sprintf("LEASE_OIL_DISPCD%02d_VOL", 0:2) := NULL]

cat(uniqueN(OG_LEASE_AVG, by=c("DISTRICT_NO", "LEASE_NO")), "leases have data after 2010", "\n")
```

## Formulate decline curves  
Typical well production in areas of interest  
```{r}
decline_params <- read_xlsx("./data/decline_curves.xlsx", sheet="decline parameters", skip=2, n_max=195)
setDT(decline_params)

setnames(decline_params, gsub("\r\n", " ", names(decline_params)))
setnames(decline_params, gsub("  ", " ", names(decline_params)))

decline_params[, "area":= gsub("(.*)-.*", "\\1", Play)]
decline_params[area=="Bonespring", "area":= "Delaware Basin"]
decline_params[area=="Wolfcamp", area:= ifelse(County %in% c("Culberson","Pecos","Reeves","Ward","Winkler","Loving"),
                                                "Delaware Basin", "Midland Basin")]
decline_params[State!="TX", "area":= NA]
decline_params[, "county":= toupper(County)]
decline_params[county=="DEWITT", county:= "DE WITT"]

decline_params[, "ratio":= (`Estimated ultimate recovery of dry natural gas (MMcf/well)` * 1000) /
                            (`Initial dry natural gas production rate (Mcf/d)` * 30.4)]
decline_params[, "scaled_ratio":= ratio * `Initial decline rate`]
```

```{r, results='hide'}
decline_params[area %in% c("Eagle Ford", "Spraberry", "Delaware Basin", "Midland Basin"),
            {boxplot(`Hyperbolic parameter`~area, main="Decline curve hyperbolic parameters",
                    ylab=expression(alpha)); NULL}]

decline_params[area %in% c("Eagle Ford", "Spraberry", "Delaware Basin", "Midland Basin"),
            {boxplot(scaled_ratio~area, main=expression("Initial production (" * Q[1] * ") & Ultimate Recovery (EUR)"),
                    ylab=expression(Delta * Q[1] %*% "EUR" ~~ "/" ~~ Q[1])); NULL}]

fwrite(decline_params[area %in% c("Eagle Ford", "Spraberry", "Delaware Basin", "Midland Basin")],
        "./processed/decline_params.csv")
```

Store decline functions as strings to evaluate given parameters  
```{r}
# offset from peak time to last data point (after which decline function is used)
OG_LEASE_AVG[, "m_shift":= .SD[, lapply(.(t_i, pmin(expiration, 201912)),
                            function(x) 12*trunc(x/100) + x %% 100)][, V2-V1]]
OG_LEASE_AVG[m_shift<0, "m_shift":= 0]

# calibrate hyperbolic parameter
OG_LEASE_AVG[!is.na(qdel_i) & ((total_oil_avg + cond_avg + total_MCF_avg/6)>0) & (q_fit>0),
        "param":= optimize(function(x) (q_fit - sum(sapply(seq(m_shift+1) - 1,
                                                    function(m) q_i / (1 + (m * x * (qdel_i / q_i)))^(1/x))))^2,
                    c(0, 1))$minimum, by=.(DISTRICT_NO, LEASE_NO)]

OG_LEASE_AVG[!is.na(q_i) & !is.na(qdel_i) & ((total_oil_avg + cond_avg + total_MCF_avg/6)>0),
            "decline_fun":= sprintf("function(dqi, len, param) 
                                        sum(sapply(%1$d + seq(len) - 1, function(m) 
                                            %2$f / (1 + (m * param * (dqi / %2$f)))^(1/param)))", m_shift, q_i)]

# clean up formatting
OG_LEASE_AVG[, "decline_fun":= gsub("\n|  ", "", decline_fun)]
```

## Determine distances to infrastructure  
Distance from leases to infrastructure is used as an ordering variable for costs 
```{r}
cat("CRS ok:", st_crs(spatial_data$gas_plants) == st_crs(spatial_data$crude_pipelines), "\n")
OG_LEASE_sf <- st_as_sf(OG_LEASE_AVG[!is.na(area)], coords=c("lon","lat"), crs=st_crs(spatial_data$gas_plants))

# measure distance to nearest facilities
# process in 10 chunks to avoid memory issues
print("Measuring distances to gas processing facilities & crude pipelines...")
OG_LEASE_sf[, c("gas_cap", "gas_dist", "crude_dist")] <- NA
for (chunk in split(1:nrow(OG_LEASE_sf), sort(rep_len(1:10, nrow(OG_LEASE_sf))))) {
    # capacity of plants weighted by inverse square of distance
    OG_LEASE_sf$gas_cap[chunk] <- apply(st_distance(spatial_data$gas_plants, OG_LEASE_sf[chunk,]), 2,
                                        function(x) weighted.mean(spatial_data$gas_plants$Cap_MMcfd, 1/x^2))
    # distance to nearest gas processing facility
    OG_LEASE_sf$gas_dist[chunk] <- apply(st_distance(spatial_data$gas_plants, OG_LEASE_sf[chunk,]), 2, min)

    # distance to nearest major crude oil pipeline
    OG_LEASE_sf$crude_dist[chunk] <- apply(st_distance(spatial_data$crude_pipelines, OG_LEASE_sf[chunk,]), 2, min)
    cat(100*max(chunk)/nrow(OG_LEASE_sf), "%   ")
}
```

Merge distance data with full lease record  
```{r}
st_geometry(OG_LEASE_sf) <- NULL
setDT(OG_LEASE_sf)
OG_LEASE_AVG[OG_LEASE_sf, on=c("DISTRICT_NO", "LEASE_NO"),
                c("gas_cap", "gas_dist", "crude_dist"):= .(gas_cap, gas_dist, crude_dist)]
rm(OG_LEASE_sf)
```

### Output complete lease records  
```{r}
fwrite(OG_LEASE_AVG[!is.na(area) & !(cond_avg+gas_avg+oil_avg==0) & !(is.na(qdel_i) | is.infinite(qdel_i))],
        file="./processed/leases_emp.csv")
```
