# EACH LEASE HAS THE FOLLOWING PROPERTIES
#   1. AVERAGE MONTHLY OIL PRODUCTION (`oil_BBL`)
#   2. AVERAGE MONTHLY GAS PRODUCTION (`gas_MCF`, `csgd_MCF`)
#   3. REMAINING TOTAL GAS PRODUCTION (`ERR_MCF`)
#   4. TOTAL LIFETIME PRODUCTION (ESTIMATED ULTIMATE RECOVERY `EUR`)
#   5. CAPITAL EXPENDITURE (`capEx`,`capEx_csgd`)
#   6. OPERATING EXPENSES:
#       - Base: dollars based on the barrel of oil equivalent production (`opEx`)
#       - Oil: per barrel of oil (`opEx_pBBL`)
#       - Gas: per thousand cubic feet of gas (`opEx_pMCF`)
#
# Production volumes are estimated using EIA production [decline curves](zotero://select/items/0_BS9HFHYN).
#
# Cost parameters are assigned by matching leases to areas and sampling data from:
# [US EIA. (2016)](zotero://select/items/0_EJYISQT4).

init_time <- Sys.time()

library(data.table)

cat("\tGenerating representative leases\n\t")
# read in example leases generated by inputs/leases.Rmd
leases_emp <- fread("./inputs/processed/leases_emp.csv", colClasses=c(LEASE_NO="character"))
wells <- unique(fread("./inputs/processed/wells.csv", colClasses=c(LEASE_NO="character")))

# Estimate capital expenditures by well in million of dollars
# assume costs are normally distributed (with 95% within range)
#    wells with shared wellpads cost less, deeper wells cost more
cat("\tAssigning well capital expenses\n\t")
wells[, "lon":= round(lon, 2)]
wells[, "depth":= round(depth, -2)]
#    capital costs are lower in the northeast Eagle Ford
setorder(wells, -shared, -lon, depth)
wells[area=="Eagle Ford",       "capExMM":= sort(rlnorm(.N, log(7.6*5.5)/2, log(7.6/5.5)/1.282/2))]
setorder(wells, -shared, depth)
wells[area=="Delaware Basin",   "capExMM":= sort(rlnorm(.N, log(8.5*5.0)/2, log(8.5/5.0)/1.282/2))]
wells[area=="Midland Basin",    "capExMM":= sort(rlnorm(.N, log(8.6*5.5)/2, log(8.6/5.5)/1.282/2))]
# only the average (2.5) is given for Spraberry. Assume a coefficient of variation of 0.2
wells[area=="Spraberry",        "capExMM":= sort(rlnorm(.N, log(2.5), sqrt(log(1+0.2^2))))]

# only horizontal wells are included in the EIA/IHS cost analysis
#   they are 1.5-2.5 times [more expensive](zotero://select/items/0_S6BJL4ZG) than vertical wells
wells[(horizontal==FALSE) & (area!="Spraberry"), "capExMM":= capExMM / runif(.N, 1.5, 2.5)]

# apply a price index to convert from 2014 dollars to historical costs (which were mostly lower)
wells[, "year":= as.numeric(substr(start, 1, 4))]

well_cost_index <- fread("./inputs/processed/well_cost_index.csv")

wells[well_cost_index, on="year", "capExMM":= capExMM * real_index_2014]
wells[(year < min(well_cost_index$year)) | is.na(start),
        "capExMM":= capExMM * well_cost_index[which.min(year), real_index_2014]]

# stacked multilaterals have one cost
wells[!leases_emp, on=c("DISTRICT_NO", "LEASE_NO"), "capExMM":= replace(capExMM, !is.na(stacked), 0)]

# wells drilled after the peak production time do not contribute to the EUR used here
wells[leases_emp[expiration>=201912], on=c("DISTRICT_NO", "LEASE_NO"),
        "capExMM":= replace(capExMM, if(isTRUE(all(start>t_i))) -which.max(start) else (start>t_i), 0), by=.EACHI]

# Lease capital expenditure is the sum of well costs (in millions of dollars)
# wells drilled later than Nov. 2019 do not contribute to the average production over 2010-2019
leases_emp[wells[!is.na(start) & (capExMM>0), .(sum(capExMM), .N), by=.(DISTRICT_NO, LEASE_NO)],
            on=c("DISTRICT_NO", "LEASE_NO"), c("capEx", "N"):= .(V1 * 10^6, N)]

leases_emp[, "capEx":= replace(capEx, is.na(N) & (start<201910), min(capEx, na.rm=TRUE)), by=area]


# Estimate operating expenses by lease (excludes natural gas liquids)
# base (pBOE):  Water, General & Administrative, Lease Operating Expenses, (ordered by productivity)
#  values estimated from [US EIA, 2016](zotero://select/items/0_EJYISQT4)
#  using [Webplotdigitizer](zotero://select/items/0_UW7H7HAP)
cat("\tAssigning lease operating expenses per barrel of oil equivalent\n\t")
leases_emp[, "BOE":= oil_avg + cond_avg + (gas_avg + csgd_avg - flared_MCF_avg)/6]
leases_emp[, "oil_perc":= (oil_avg + cond_avg) / BOE]
setorder(leases_emp, oil_perc, -BOE)

leases_emp[area=="Eagle Ford" & (oil_avg>0 | (cond_avg>0 & gas_avg==0)),                            # oil
                "opEx_pBOE":= sort(rlnorm(.N, log(15.2*9.3)/2, log(15.2/9.3)/1.282/2))]
leases_emp[area=="Eagle Ford" & gas_avg>0 & cond_avg>0,                                             # wet gas
                "opEx_pBOE":= sort(rlnorm(.N, log(13.5*6.7)/2, log(13.5/6.7)/1.282/2))]
leases_emp[area=="Eagle Ford" & ((gas_avg>0 & cond_avg==0) | (csgd_avg>0 & oil_avg==0)),            # dry gas
                    "opEx_pBOE":= sort(rlnorm(.N, log(10.3*5.3)/2, log(10.3/5.3)/1.282/2))]
leases_emp[area=="Delaware Basin",
                "opEx_pBOE":= sort(rlnorm(.N, log(16.1*7.7)/2, log(16.1/7.7)/1.282/2))]
leases_emp[area %in% c("Midland Basin","Spraberry"),
                "opEx_pBOE":= sort(rlnorm(.N, log(16.1*7.9)/2, log(16.1/7.9)/1.282/2))]



# oil (pBBL):   Short Transportation, Long Transportation (ordered by how oil moves & distance from crude pipelines)
# cond (pBBL):  Long Transportation, NGL fractionation (ordered by how oil moves & distance from crude pipelines)
cat("\tAssigning lease operating expenses per barrel of oil\n\t")
setorder(leases_emp, -pipe_frac, -rail_frac, crude_dist)

leases_emp[area=="Eagle Ford" & oil_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(6*3.75)/2, log(6/3.75)/1.282/2))]
leases_emp[area=="Eagle Ford" & cond_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(5.64*4.72)/2, log(5.64/4.72)/1.282/2))]
leases_emp[area=="Delaware Basin" & oil_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(16*4.25)/2, log(16/4.25)/1.282/2))]
leases_emp[area=="Delaware Basin" & cond_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(13.78*6.13)/2, log(13.78/6.13)/1.282/2))]
leases_emp[area %in% c("Midland Basin","Spraberry") & oil_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(15.5*4.25)/2, log(15.5/4.25)/1.282/2))]
leases_emp[area %in% c("Midland Basin","Spraberry") & cond_avg>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(13.38*5.29)/2, log(13.38/5.29)/1.282/2))]

leases_emp[oil_avg+cond_avg==0, "opEx_pBBL":= 0]


# gas (pMCF):   Gathering & Transportation, Processing (ordered by % flared & inverse-square distance weighted capacity)
# There is not gas processing fee for dry gas
cat("\tAssigning lease operating expenses per thousand cubic feet of gas\n\t")
leases_emp[gas_avg+csgd_avg>0, "percent_flared":=  round(flared_MCF_avg / (gas_avg+csgd_avg), 2)]
setorder(leases_emp, percent_flared, -gas_cap)

leases_emp[area=="Eagle Ford" & csgd_avg>0,                                                         # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(1.60*0.85)/2, log(1.60/0.85)/1.282/2))]
leases_emp[area=="Eagle Ford" & gas_avg>0 & cond_avg>0,                                             # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.60*0.85)/2, log(1.60/0.85)/1.282/2))]
leases_emp[area=="Eagle Ford" & gas_avg>0 & cond_avg==0,                                            # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.05*0.55)/2, log(1.05/0.55)/1.282/2))]

leases_emp[area=="Delaware Basin" & csgd_avg>0,                                                     # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(2.35*0.85)/2, log(2.35/0.85)/1.282/2))]
leases_emp[area=="Delaware Basin" & gas_avg>0 & cond_avg>0,                                         # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(2.35*0.85)/2, log(2.35/0.85)/1.282/2))]
leases_emp[area=="Delaware Basin" & gas_avg>0 & cond_avg==0,                                        # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.10*0.60)/2, log(1.10/0.60)/1.282/2))]

leases_emp[area %in% c("Midland Basin","Spraberry") & csgd_avg>0,                                   # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(1.70*0.85)/2, log(1.70/0.85)/1.282/2))]
leases_emp[area %in% c("Midland Basin","Spraberry") & gas_avg>0 & cond_avg>0,                       # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.70*0.85)/2, log(1.70/0.85)/1.282/2))]
leases_emp[area %in% c("Midland Basin","Spraberry") & gas_avg>0 & cond_avg==0,                      # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(0.90*0.60)/2, log(0.90/0.60)/1.282/2))]

leases_emp[gas_avg+csgd_avg==0, "opEx_pMCF":= 0]


## Estimate average production using decline curves
decline_params <- fread("./inputs/processed/decline_params.csv")
leases_emp[decline_params[, .(.(`Hyperbolic parameter`)), by=area], on="area", "param0":= sapply(V1, sample, 1)]
# match on counties where possible
leases_emp[decline_params, on=c("county", "area"), "param0":= `Hyperbolic parameter`]

# recalibrate initial production decline where necessary
leases_emp[!between(param, min(param0), max(param0)),
        "qdel_i":= optimize(function(x) (q_fit - eval(parse(text=decline_fun))(x, -m_shift+1, param0))^2,
                    c(0, q_i), tol=10)$minimum, by=.(DISTRICT_NO, LEASE_NO)]

leases_emp[!between(param, min(param0), max(param0)),
        "param":= optimize(function(x) (q_fit - eval(parse(text=decline_fun))(qdel_i, -m_shift+1, x))^2,
                    c(0, 1))$minimum, by=.(DISTRICT_NO, LEASE_NO)]

# historical data range, maximally, from Jan 2010 - Dec 2019
#    determine number of additional months to estimate in order to average over entire model run
leases_emp[, "len_est":= .SD[, lapply(.(pmin(expiration, 201912), pmax(start, 201001)),
                            function(x) 12*trunc(x/100) + x %% 100)][, (V2 + (Params$tf-Params$t0)) - V1]]
leases_emp[len_est<0, "len_est":= 0]

# number of years to average over
leases_emp[, "len_avg":= (Params$tf-Params$t0) - ifelse(expiration<201912, len_est-1, 0)]

# scale production to average over model runtime
leases_emp[(expiration>=201912) & (len_est>0) & (decline_fun!=""),
        "mult":= ((eval(parse(text=decline_fun))(qdel_i, len_est, param) + qcum_i_BBL + qcum_i_MCF/6) / len_avg) /
                    (total_oil_avg + cond_avg + total_MCF_avg/6),
        by=.(DISTRICT_NO, LEASE_NO)]

# project the Estimated Ultimate Recovery (EUR) (over 360 months following EIA decline curves)
leases_emp[(expiration>=201912) & (decline_fun!=""),
            "EUR":= (eval(parse(text=decline_fun))(qdel_i, 360, param) +
                    (qcum_0_BBL + qcum_i_BBL + (qcum_0_MCF + qcum_i_MCF)/6)), by=.(DISTRICT_NO, LEASE_NO)]
#     no need to estimate production for leases which have already expired
leases_emp[(expiration<201912) | is.na(mult),
            c("mult", "EUR"):= .(1, (qcum_0_BBL + qcum_i_BBL) + (qcum_0_MCF + qcum_i_MCF)/6)]

leases_emp[, "EUR_MCF":= 6 * (EUR * ((csgd_avg + gas_avg)/6) / (oil_avg + cond_avg + (csgd_avg + gas_avg)/6))]
leases_emp[, "EUR_BBL":= (EUR * (oil_avg + cond_avg) / (oil_avg + cond_avg + (csgd_avg + gas_avg)/6))]

leases_emp[, "EUR_MCF":= pmax(EUR_MCF, qcum_0_MCF+qcum_i_MCF)]
leases_emp[, "EUR_BBL":= pmax(EUR_BBL, qcum_0_BBL+qcum_i_BBL)]
leases_emp[, "EUR":= EUR_BBL + EUR_MCF/6]

# project the Estimated Remaining Recovery (ERR) of gas
leases_emp[, "ERR_MCF":= EUR_MCF - qcum_0_MCF]
leases_emp[start>=201001, "ERR_MCF":= EUR_MCF]
leases_emp[expiration<201912, "ERR_MCF":= qcum_i_MCF]

leases_emp[, c("model_oil_BBL", "model_cond_BBL", "model_gas_MCF", "model_csgd_MCF", "flared_MCF"):=
            .(oil_avg,          cond_avg,           gas_avg,        csgd_avg,       flared_MCF_avg)]
leases_emp[total_MCF_avg>0, "model_gas_MCF":=  pmin(EUR_MCF/len_avg,  gas_avg * mult)]
leases_emp[total_MCF_avg>0, "model_csgd_MCF":= pmin(EUR_MCF/len_avg, csgd_avg * mult)]
leases_emp[total_oil_avg>0, "model_oil_BBL":=  pmin(EUR_BBL/len_avg, oil_avg * mult)]

leases_emp[total_MCF_avg>0,
    "flared_MCF":= (model_gas_MCF + model_csgd_MCF) * flared_MCF_avg / (gas_avg + csgd_avg)]
leases_emp[(model_gas_MCF + model_csgd_MCF)==0, "flared_MCF":= 0]


# cost to install $31,250 compressor with 5,475 MCF/month capacity [USA EPA, 2016](zotero://select/items/0_VD6GIMT4)
leases_emp[model_csgd_MCF>0, "capEx_csgd":= 31250 * nafill(N, fill=1) * ceiling(flared_MCF/5475/nafill(N, fill=1))]
# each compressor costs $7,350 per year to operate
leases_emp[model_csgd_MCF>0, "opEx_pMCF":= opEx_pMCF + (612.5 * (capEx_csgd / 31250) / model_csgd_MCF)]


# initialize firms
cat("Generating representative firms\n\t")
firms <- data.table("firmID"= 1:Params$nagents, key= "firmID",
                    # how much oil (BBL) and gas (MCF) does the firm produce each time step
                    "oil_output"= NA_real_, "oil_revenue"= NA_real_,
                    "gas_output"= NA_real_, "gas_revenue"= NA_real_,
                    "grey_gas_sold"= NA_real_, "green_gas_sold"= NA_real_, "gas_flared"= NA_real_,
                    # Valuations; costs include Operating, Mitigation, Capital Expenditures
                    "sales"= 0, "profit"= 0, "market_value"= NA_real_,
                    "cost_O"= NA_real_, "cost_M"= NA_real_, "cost_CE"= NA_real_, "sPressure"= NA_real_,
                    # activities: exploration, development; behaviors: flaring, mitigating, economizing, imitating
                    "activity"= NA_character_, "behavior"= NA_character_,
                    "time"= Params$t0-1)

# Assign firms maximum production capacity based on empirics (oil production is log-normally distributed)
market_shares <- fread("./inputs/processed/firm_market_shares.csv")

# assign oil leases to agents according to their total production
cat("\tAssigning oil leases to firms\n\t")
leases_emp[, "firmID":= NA_integer_]

firms[, "production_BBL":= 0]
while(!between(sum(firms$production_BBL)/mean(market_shares[, sum(scaled_oil_BBL), by=.(CYCLE_YEAR, CYCLE_MONTH)]$V1), 0.8, 0.85)) {
    firms[, "production_BBL":= rlnorm(.N, mean(log(market_shares$scaled_oil_BBL)),
                                            sd(log(market_shares$scaled_oil_BBL)))]
}

for (ID in firms[order(production_BBL)]$firmID) {
    rem_capacity <- firms[ID, production_BBL] - leases_emp[firmID==ID, sum(total_oil_avg)]
    while (rem_capacity - min(leases_emp[is.na(firmID) & (oil_avg>0)]$total_oil_avg) > 0) {
        leases_emp[sample(.N, 1, prob=(is.na(firmID) & (oil_avg>0) & (rem_capacity - total_oil_avg > 0)) / log(2+csgd_avg)), "firmID":= ID]
        rem_capacity <- firms[ID, production_BBL] - leases_emp[firmID==ID, sum(total_oil_avg)]
    }
    leases_emp[is.na(firmID) & oil_avg>0, "firmID":= replace(firmID, which.min(oil_avg), ID)]
}

# assign gas leases to agents according to their total production
cat("\tAssigning gas leases to firms\n\t")

firms[, "production_MCF":= 0]
while(!between(sum(firms$production_MCF)/mean(market_shares[, sum(scaled_gas_MCF), by=.(CYCLE_YEAR, CYCLE_MONTH)]$V1), 0.8, 0.85)) {
    firms[order(log(production_BBL) * runif(.N, 0.5, 1.5)),
            "production_MCF":= sort(rlnorm(.N, mean(log(market_shares[scaled_gas_MCF>0, scaled_gas_MCF])),
                                                sd(log(market_shares[scaled_gas_MCF>0, scaled_gas_MCF]))))]
    # a large fraction (~40%) of firms operate oil leases only
    firms[runif(.N) < market_shares[, sum(scaled_gas_MCF==0)/length(scaled_gas_MCF)], "production_MCF":= 0]
}

for (ID in firms[production_MCF>0][order(production_MCF)]$firmID) {
    rem_capacity <- firms[ID, production_MCF] - leases_emp[firmID==ID & gas_avg>0, sum(total_MCF_avg)]
    while (rem_capacity - min(leases_emp[is.na(firmID) & (gas_avg>0)]$total_MCF_avg) > 0) {
        leases_emp[sample(.N, 1, prob=is.na(firmID) & (gas_avg>0) & (rem_capacity - total_MCF_avg > 0)), "firmID":= ID]
        rem_capacity <- firms[ID, production_MCF] - leases_emp[firmID==ID & gas_avg>0, sum(total_MCF_avg)]
    }
    leases_emp[is.na(firmID) & gas_avg>0, "firmID":= replace(firmID, which.min(gas_avg), ID)]
}

# calculate lease lifetime in months

# estimate lifetime based on remaining recoverable resource
# estimate lifetime based on initial production rate at t_i and total production since t_i
leases_emp[(expiration>=201912) & (decline_fun!=""),
            "q_curve":= (eval(parse(text=decline_fun))(qdel_i, -m_shift+1, param) + EUR -
                    (qcum_0_BBL + qcum_i_BBL + (qcum_0_MCF + qcum_i_MCF)/6)), by=.(DISTRICT_NO, LEASE_NO)]
leases_emp[expiration<201912, "q_curve":= q_fit]

# number of months of production after t_i
leases_emp[, "m_rem":= .SD[, lapply(.(expiration, t_i), function(x) 12*trunc(x/100) + x %% 100)][, 1+V1-V2]]
leases_emp[order(-log(q_i/q_curve) * runif(.N, 0.5, 1.5)),
       "m_rem":= ifelse(expiration<201912, m_rem,
                                sort(sample(m_rem[(start>199301) & (expiration<201912)], .N, replace=TRUE))), by=area]


# extend lifetime by the predicted remaing months
leases_emp[, "lifetime":= .SD[, lapply(.(t_i, start, expiration), function(x) 12*trunc(x/100) + x %% 100)][,
                            pmax(1+V3-V2, m_rem + V1-V2)]]


# offest for delay between lease discovery and becoming operational
leases_emp[!is.na(firmID), "lifetime":= lifetime+2]

# extract modeled data from the empirical lease data
leases <- leases_emp[, .(area, DISTRICT_NO, OIL_GAS_CODE,
                        "oil_BBL"= model_oil_BBL, "cond_BBL"= model_cond_BBL,
                        "gas_MCF"= model_gas_MCF, "csgd_MCF"= model_csgd_MCF, ERR_MCF, EUR,
                        capEx, capEx_csgd, opEx_pBBL, opEx_pMCF,
                        # empirical BOEs sold to calculate the baseline operating cost
                        "opEx"= opEx_pBOE * (model_oil_BBL + cond_avg + (model_gas_MCF + model_csgd_MCF - flared_MCF)/6),
                        "opEx_oil"= NA_real_, "opEx_csgd"= NA_real_, "opEx_gas"= NA_real_,
                        "class"= "", "status"= "", "market"= "",
                        start, expiration, lifetime,
                        "t_found"= NA_integer_, "t_switch"= NA_integer_, "time"= Params$t0-1,
                        firmID)]

leases[, "leaseID":= .I]
setkey(leases, leaseID)

leases[!is.na(firmID), "t_found":= Params$t0 - sample(lifetime-1, 1), by=leaseID]
leases[!is.na(firmID) & (expiration<201912),
        "t_found":= .SD[, lapply(.(expiration, 201001), function(x) 12*trunc(x/100) + x %% 100)][, 1+V1-V2] - lifetime]

# offset for first time step
leases[!is.na(firmID) & ERR_MCF>0, "ERR_MCF":= ERR_MCF + (gas_MCF+csgd_MCF)]

leases[!is.na(firmID), c("class", "status", "market"):=
        .(ifelse(csgd_MCF>0, "underdeveloped", "developed"), "producing", "grey")]
# historically (2004-2010), gas prices were much higher (~$7/MCF). Develop leases which are at least 10 years old accordingly
leases[!is.na(firmID) & csgd_MCF>0 & ((Params$t0 - t_found)>=120),
        "class":= replace(class, opEx_pMCF + (capEx_csgd / csgd_MCF / lifetime) < 7, "developed")]
leases[!is.na(firmID) & (csgd_MCF>0) & (class=="developed"), "t_switch":= t_found]

# calculate lease operating expenses
leases[, sprintf("opEx_%s", c("oil","csgd","gas")):= lease_opEx(.SD)]

# initially there is no social pressure
firms[, "sPressure":= 0]

# initial flaring intensity
firms[leases[!is.na(firmID), .(sum(oil_BBL+cond_BBL), sum(gas_MCF), sum(csgd_MCF[class=="underdeveloped"])), by=firmID], on="firmID",
        c("oil_output", "gas_output", "gas_flared"):= .(V1, V2, V3)]
firms[, "behavior":= ifelse(gas_flared/oil_output > Params$threshold, "flaring", "economizing")]

firms[leases[, sum(opEx_oil + opEx_gas), by=firmID], on="firmID", "cost_O":= V1]
firms[, c("cost_M", "green_gas_sold"):= 0]


# create demand function
cat("Generating representative demand functions\n")
historical_market_data <- fread("./inputs/processed/historical_NG_demand.csv", integer64="numeric")
historical_market_data[
        market_shares[, sum(OPER_GAS_PROD_VOL+OPER_CSGD_PROD_VOL), by=.("year"=CYCLE_YEAR, "month"=month.abb[CYCLE_MONTH])],
        on=c("year","month"), "frac":= leases_emp[!is.na(firmID), sum(model_gas_MCF+model_csgd_MCF-flared_MCF)] / V1]

# create an object which encapsulates the necessary demand data and generates demand schedules
demand <-
    setRefClass("demand_function",
        fields =  list(historical_market="data.table"),
        methods = list(
            new_schedule = function(prop_green, sample_set=list()) {
                while (NROW(sample_set) < 1) {
                    sample_set <- historical_market[runif(.N) < (0.5/.N), .(year, month)]
                }
                cat("Generating demand function from:", paste(sample_set[[2]], sample_set[[1]], collapse=", "), "\n")

                # price elasticity of demand
                ep_grey  <- -0.18

                p0 <- historical_market[sample_set, mean(p)]
                q0 <- historical_market[sample_set, mean(q)]
                # the historic qauntity demanded is
                #    the fraction of gas produced in Texas (q_TX)
                #    the fraction of Texas gas produced by "associated" operators (~95%)
                #    the fraction of those operators' gas production actually assigned to firms (frac)
                #    a factor to keep the combined production volume roughly constant across green and grey markets
                q0p <- historical_market[sample_set, mean(q_TX * 0.95 * frac * (1-prop_green))]

                # slope of the inverse demand function given ep
                m <- (p0 / q0) * (1 / ep_grey)

                # price (y) and quantity (x) intercept of grey demand curve
                b <- p0 - (m * q0p)
                q_int_grey <- -(b / m)

                # green demand represents a rotation of the demand curve about the quantity intercept
                #    [Sedjo & Swallow 2002](zotero://select/items/0_GGH3Y8UX)
                # green electricity consumers pay a premium of [7-30%](./inputs/market_history.html)
                premium <- runif(1, 1.07, 1.3) * (((m * q0p) + b) / (prop_green * (m * q0p) + b))
                b_green <- premium * b

                # shift green demand curve to account for max market size
                q_int_green <- max(prop_green * q_int_grey, 1e-10)

                return(function(q) {
                            p_grey=  nafill(approx(c(0, q_int_grey),  c(b,        0), q)$y, fill=0)
                            p_green= nafill(approx(c(0, q_int_green), c(b_green,  0), q)$y, fill=0)

                            return(data.table(q, "p_grey"= if (prop_green==1) 0 else p_grey,
                                                "p_green"= if (prop_green==0) 0 else p_green))
                })
            })
    )$new(historical_market=na.omit(historical_market_data[, .SD, keyby=.(year, month)]))


# generate validation report for this initialization
cat("Writing validation report\n")
rmarkdown::render("flaringABM_validation_init.Rmd", output_format="html_document",
                output_file=sprintf("%s/outputs/validation/init_%s_%s.html",
                        ifelse(Sys.getenv("WORK")=="", ".", paste0(Sys.getenv("WORK"),"/flaringABM")), jobID, Run),
                intermediates_dir=sprintf("./outputs/validation/init_%s_%s", jobID, Run), quiet=TRUE)
unlink(sprintf("./outputs/validation/init_%s_%s", jobID, Run), recursive=TRUE)

# done
cat("Cleaning up\n\t")
rm(wells, leases_emp, ID, market_shares, rem_capacity, historical_market_data, decline_params)
gc()

cat(gsub("Time difference of", "Initialization complete in", capture.output(Sys.time() - init_time)), "\n")
