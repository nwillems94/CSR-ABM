init_time <- Sys.time()

library(data.table)

cat("\tGenerating representative leases\n\t")
# read in example leases generated by inputs/leases.Rmd
leases_full <- fread("./inputs/processed/leases_full.csv")
wells <- fread("./inputs/processed/wells.csv")

# Estimate capital expenditures by well in million of dollars
# assume costs are normally distributed (with 95% within range) and increase with well depth
cat("\tAssigning well capital expenses\n\t")
setorder(wells, depth)
wells[area=="Eagle Ford",       "capExMM":= sort(rlnorm(.N, log(9.6*5.9)/2, log(9.6/5.9)/1.282/2))]
wells[area=="Delaware Basin",   "capExMM":= sort(rlnorm(.N, log(8.5*5.0)/2, log(8.5/5.0)/1.282/2))]
wells[area=="Midland Basin",    "capExMM":= sort(rlnorm(.N, log(8.6*5.5)/2, log(8.6/5.5)/1.282/2))]
# only the average (2.5) is given for Spraberry. Assume a coefficient of variation of 0.2
wells[area=="Spraberry",        "capExMM":= sort(rlnorm(.N, log(2.5), sqrt(log(1+0.2^2))))]

# Lease capital expenditure is the sum of well costs (in millions of dollars)
leases_full[wells[, .(sum(capExMM), .N), by=.(DISTRICT_NO, LEASE_NO)], on=c("DISTRICT_NO", "LEASE_NO"),
                c("capEx", "N"):= .(V1 * 10^6, N)]

# Each gas lease should only have 1 well
leases_full <- leases_full[!(OIL_GAS_CODE=="G" & N>1)]
# Drop outlier oil leases
leases_full <- leases_full[!(OIL_GAS_CODE=="O" & N>quantile(N[OIL_GAS_CODE=="O"], 0.99))]
# Drop leases that appear to be flaring without any production
leases_full <- leases_full[!(gas_MCF>0 & (flared_MCF / gas_MCF)>0.25 & cond_BBL / (gas_MCF/6)<1)]

# Estimate operating expenses by lease (excludes natural gas liquids)
# base (pBOE):  Water, General & Administrative, Lease Operating Expenses, (ordered by productivity)
#  values estimated from [US EIA, 2016](zotero://select/items/0_EJYISQT4)
#  using [Webplotdigitizer](zotero://select/items/0_UW7H7HAP)
cat("\tAssigning lease operating expenses per barrel of oil equivalent\n\t")
leases_full[, "BOE":= oil_BBL + cond_BBL + (gas_MCF + csgd_MCF - flared_MCF)/6]
leases_full[, "oil_perc":= (oil_BBL + cond_BBL) / BOE]
setorder(leases_full, oil_perc, -BOE)

leases_full[area=="Eagle Ford" & oil_BBL>0,                                                         # oil
                "opEx_pBOE":= sort(rlnorm(.N, log(15.2*9.3)/2, log(15.2/9.3)/1.282/2))]
leases_full[area=="Eagle Ford" & gas_MCF>0 & cond_BBL>0,                                            # wet gas
                "opEx_pBOE":= sort(rlnorm(.N, log(13.5*6.7)/2, log(13.5/6.7)/1.282/2))]
leases_full[area=="Eagle Ford" & gas_MCF>0 & cond_BBL==0,                                           # dry gas
                    "opEx_pBOE":= sort(rlnorm(.N, log(10.3*5.3)/2, log(10.3/5.3)/1.282/2))]
leases_full[area=="Delaware Basin",
                "opEx_pBOE":= sort(rlnorm(.N, log(16.1*7.7)/2, log(16.1/7.7)/1.282/2))]
leases_full[area %in% c("Midland Basin","Spraberry"),
                "opEx_pBOE":= sort(rlnorm(.N, log(16.1*7.9)/2, log(16.1/7.9)/1.282/2))]

# Use the empirical BOEs sold to calculate the baseline operating cost
leases_full[, "opEx" := opEx_pBOE * BOE]


# oil (pBBL):   Short Transportation, Long Transportation (ordered by how oil moves & distance from crude pipelines)
# cond (pBBL):  Long Transportation, NGL fractionation (ordered by how oil moves & distance from crude pipelines)
cat("\tAssigning lease operating expenses per barrel of oil\n\t")
setorder(leases_full, -pipe_frac, -rail_frac, crude_dist)

leases_full[area=="Eagle Ford" & oil_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(6*3.75)/2, log(6/3.75)/1.282/2))]
leases_full[area=="Eagle Ford" & cond_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(5.64*4.72)/2, log(5.64/4.72)/1.282/2))]
leases_full[area=="Delaware Basin" & oil_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(16*4.25)/2, log(16/4.25)/1.282/2))]
leases_full[area=="Delaware Basin" & cond_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(13.78*6.13)/2, log(13.78/6.13)/1.282/2))]
leases_full[area %in% c("Midland Basin","Spraberry") & oil_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(15.5*4.25)/2, log(15.5/4.25)/1.282/2))]
leases_full[area %in% c("Midland Basin","Spraberry") & cond_BBL>0,
                "opEx_pBBL":= sort(rlnorm(.N, log(13.38*5.29)/2, log(13.38/5.29)/1.282/2))]

leases_full[oil_BBL+cond_BBL==0, "opEx_pBBL":= 0]


# gas (pMCF):   Gathering & Transportation, Processing (ordered by % flared & inverse-square distance weighted capacity)
# There is not gas processing fee for dry gas
cat("\tAssigning lease operating expenses per thousand cubic feet of gas\n\t")
leases_full[gas_MCF+csgd_MCF>0, "percent_flared":=  round(flared_MCF / (gas_MCF+csgd_MCF), 2)]
setorder(leases_full, percent_flared, -gas_cap)

leases_full[area=="Eagle Ford" & csgd_MCF>0,                                                        # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(1.25*1.60*0.85)/2, log(1.25*1.60/0.85)/1.282/2))]
leases_full[area=="Eagle Ford" & gas_MCF>0 & cond_BBL>0,                                            # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.60*0.85)/2, log(1.60/0.85)/1.282/2))]
leases_full[area=="Eagle Ford" & gas_MCF>0 & cond_BBL==0,                                           # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.05*0.55)/2, log(1.05/0.55)/1.282/2))]

leases_full[area=="Delaware Basin" & csgd_MCF>0,                                                    # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(1.25*2.35*0.85)/2, log(1.25*2.35/0.85)/1.282/2))]
leases_full[area=="Delaware Basin" & gas_MCF>0 & cond_BBL>0,                                        # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(2.35*0.85)/2, log(2.35/0.85)/1.282/2))]
leases_full[area=="Delaware Basin" & gas_MCF>0 & cond_BBL==0,                                       # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.10*0.60)/2, log(1.10/0.60)/1.282/2))]

leases_full[area %in% c("Midland Basin","Spraberry") & csgd_MCF>0,                                  # oil
                "opEx_pMCF":= sort(rlnorm(.N, log(1.25*1.70*0.85)/2, log(1.25*1.70/0.85)/1.282/2))]
leases_full[area %in% c("Midland Basin","Spraberry") & gas_MCF>0 & cond_BBL>0,                      # wet gas
                "opEx_pMCF":= sort(rlnorm(.N, log(1.70*0.85)/2, log(1.70/0.85)/1.282/2))]
leases_full[area %in% c("Midland Basin","Spraberry") & gas_MCF>0 & cond_BBL==0,                     # dry gas
                "opEx_pMCF":= sort(rlnorm(.N, log(0.90*0.60)/2, log(0.90/0.60)/1.282/2))]

leases_full[gas_MCF+csgd_MCF==0, "opEx_pMCF":= 0]


# cost to install compressor with 5,475 MCF/month capacity at cost of $31,250 [USA EPA, 2016](zotero://select/items/0_VD6GIMT4)
leases_full[csgd_MCF>0, "capEx_csgd":= 31250 * ceiling(flared_MCF/5475)]


leases <- leases_full[, .(oil_BBL, cond_BBL, gas_MCF, csgd_MCF,
                          total_oil_BBL, total_MCF, flared_MCF,
                          capEx, capEx_csgd, opEx, opEx_pBBL, opEx_pMCF,
                          start, expiration, area, DISTRICT_NO, FIELD_NO, OIL_GAS_CODE)]

# calculate lease lifetime in months
leases[, "lifetime":= .SD[, lapply(.(expiration, start), function(x) 12*trunc(x/100) + x %% 100)][, V1-V2]]
leases <- leases[!(lifetime<12 & expiration<max(expiration))]
#   for leases that are still operating, estimate a lifetime based on historical distribution
leases[expiration==max(expiration),
        "lifetime":= sapply(lifetime, function(x) leases[OIL_GAS_CODE==.BY & lifetime>x, sample(c(lifetime, x), 1)]),
        by=OIL_GAS_CODE]

leases[oil_BBL==0,          opEx_pBBL:= 0]
leases[gas_MCF+csgd_MCF==0, opEx_pMCF:= 0]

# apply a price index to convert from 2014 dollars to historical costs (which were mostly lower)
well_cost_index <- fread("./inputs/processed/well_cost_index.csv")

leases[well_cost_index[, cbind("date"=as.numeric(sprintf("%d%02d", year, 1:12)), .SD), by=year], on=c(start="date"),
        "capEx":= capEx * real_index_2014]
leases[substr(start, 1, 4) < min(well_cost_index$year),
        "capEx":= capEx * well_cost_index[which.min(year), real_index_2014]]

# Assign other lease attributes
leases[, "firmID":= NA_integer_]
leases[, c("t_found","t_switch"):= NA_integer_]
leases[, c("class","status","market"):= ""]
leases[, "time":= Params$t0-1]

leases[, "leaseID":= .I]
setkey(leases, leaseID)


# initialize firms
cat("Generating representative firms\n\t")
firms <- data.table("firmID"= 1:Params$nagents, key= "firmID",
                    # how much oil (BBL) and gas (MCF) does the firm produce each time step
                    "oil_output"= NA_real_, "oil_revenue"= NA_real_,
                    "gas_output"= NA_real_, "gas_revenue"= NA_real_,
                    "grey_gas_sold"= NA_real_, "green_gas_sold"= NA_real_, "gas_flared"= NA_real_,
                    # Valuations; costs include Operating, Mitigation, Capital Expenditures
                    "sales"= 0, "profit"= 0, "market_value"= NA_real_,
                    "cost_O"= NA_real_, "cost_M"= NA_real_, "cost_CE"= NA_real_, "sPressure"= NA_real_,
                    # activities: exploration, development; behaviors: flaring, mitigating, economizing, imitating
                    "activity"= NA_character_, "behavior"= NA_character_,
                    "time"= Params$t0-1)

# Assign firms maximum production capacity based on empirics (oil production is log-normally distributed)
market_shares <- fread("./inputs/processed/firm_market_shares.csv")

# assign oil leases to agents according to their total production
cat("\tAssigning oil leases to firms\n\t")

firms[, "production_BBL":= 0]
while(!between(sum(firms$production_BBL)/mean(market_shares[, sum(scaled_oil_BBL), by=.(CYCLE_YEAR, CYCLE_MONTH)]$V1), 0.8, 0.85)) {
    firms[, "production_BBL":= rlnorm(.N, mean(log(market_shares$scaled_oil_BBL)),
                                            sd(log(market_shares$scaled_oil_BBL)))]
}

for (ID in firms[order(production_BBL)]$firmID) {
    leases[is.na(firmID) & oil_BBL>0, "firmID":= replace(firmID, which.min(total_oil_BBL), ID)]

    rem_capacity <- firms[ID, production_BBL] - leases[firmID==ID, sum(total_oil_BBL)]
    while (rem_capacity - min(leases[is.na(firmID) & (oil_BBL>0)]$total_oil_BBL) > 0) {
        leases[sample(.N, 1, prob=(is.na(firmID) & (oil_BBL>0) & (rem_capacity - total_oil_BBL > 0)) / log(2+csgd_MCF)), "firmID":= ID]
        rem_capacity <- firms[ID, production_BBL] - leases[firmID==ID, sum(total_oil_BBL)]
    }
}

# assign gas leases to agents according to their total production
cat("\tAssigning gas leases to firms\n\t")

firms[, "production_MCF":= 0]
while(!between(sum(firms$production_MCF)/mean(market_shares[, sum(scaled_gas_MCF), by=.(CYCLE_YEAR, CYCLE_MONTH)]$V1), 0.8, 0.85)) {
    firms[order(log(production_BBL) * runif(.N, 0.5, 1.5)),
            "production_MCF":= sort(rlnorm(.N, mean(log(market_shares[scaled_gas_MCF>0, scaled_gas_MCF])),
                                                sd(log(market_shares[scaled_gas_MCF>0, scaled_gas_MCF]))))]
    # a large fraction (~40%) of firms operate oil leases only
    firms[runif(.N) < market_shares[, sum(scaled_gas_MCF==0)/length(scaled_gas_MCF)], "production_MCF":= 0]
}

for (ID in firms[production_MCF>0][order(production_MCF)]$firmID) {
    leases[is.na(firmID) & gas_MCF>0, "firmID":= replace(firmID, which.min(total_MCF), ID)]

    rem_capacity <- firms[ID, production_MCF] - leases[firmID==ID & gas_MCF>0, sum(total_MCF)]
    while (rem_capacity - min(leases[is.na(firmID) & (gas_MCF>0)]$total_MCF) > 0) {
        leases[sample(.N, 1, prob=is.na(firmID) & (gas_MCF>0) & (rem_capacity - total_MCF > 0)), "firmID":= ID]
        rem_capacity <- firms[ID, production_MCF] - leases[firmID==ID & gas_MCF>0, sum(total_MCF)]
    }
}

leases[!is.na(firmID), "t_found":= Params$t0 - sample(lifetime-1, 1), by=leaseID]

leases[!is.na(firmID), c("class", "status", "market"):=
        .(ifelse(csgd_MCF>0, "underdeveloped", "developed"), "producing", "grey")]
# historically (2004-2010), gas prices were much higher (~$7/MCF). Develop leases which are at least 10 years old accordingly
leases[!is.na(firmID) & csgd_MCF>0 & ((Params$t0 - t_found)>=120),
        "class":= replace(class, opEx_pMCF + (capEx_csgd / csgd_MCF / lifetime) < 7, "developed")]
leases[!is.na(firmID) & (csgd_MCF>0) & (class=="developed"), "t_switch":= t_found]

# calculate lease operating expenses
leases[, sprintf("opEx_%s", c("oil","csgd","gas")):= lease_opEx(.SD)]

# initially there is no social pressure
firms[, "sPressure":= 0]

# initial flaring intensity
firms[leases[!is.na(firmID), .(sum(oil_BBL+cond_BBL), sum(gas_MCF), sum(csgd_MCF[class=="underdeveloped"])), by=firmID], on="firmID",
        c("oil_output", "gas_output", "gas_flared"):= .(V1, V2, V3)]
firms[, "behavior":= ifelse(gas_flared/oil_output > Params$threshold, "flaring", "economizing")]

firms[leases[, sum(opEx_oil + opEx_gas), by=firmID], on="firmID", "cost_O":= V1]
firms[, c("cost_M", "green_gas_sold"):= 0]


# create demand function
cat("Generating representative demand functions\n")

historical_market_data <- fread("./inputs/processed/historical_NG_demand.csv", integer64="numeric")
historical_market_data[
        market_shares[, sum(OPER_GAS_PROD_VOL+OPER_CSGD_PROD_VOL), by=.("year"=CYCLE_YEAR, "month"=month.abb[CYCLE_MONTH])],
        on=c("year","month"), "frac":= leases[!is.na(firmID), sum(gas_MCF+csgd_MCF-flared_MCF)] / V1]

# create an object which encapsulates the necessary demand data and generates demand schedules
demand <-
    setRefClass("demand_function",
        fields =  list(historical_market="data.table"),
        methods = list(
            new_schedule = function(prop_green, sample_set=list()) {
                while (NROW(sample_set) < 1) {
                    sample_set <- historical_market[runif(.N) < (0.5/.N), .(year, month)]
                }
                cat("Generating demand function from:", paste(sample_set[[2]], sample_set[[1]], collapse=", "), "\n")

                # price elasticity of demand
                ep_grey  <- -0.18

                p0 <- historical_market[sample_set, mean(p)]
                q0 <- historical_market[sample_set, mean(q)]
                # the historic qauntity demanded is
                #    the fraction of gas produced in Texas (q_TX)
                #    the fraction of Texas gas produced by "associated" operators (~95%)
                #    the fraction of those operators' gas production actually assigned to firms (frac)
                #    a factor to keep the combined production volume roughly constant across green and grey markets
                q0p <- historical_market[sample_set, mean(q_TX * 0.95 * frac * (1-prop_green))]

                # slope of the inverse demand function given ep
                m <- (p0 / q0) * (1 / ep_grey)

                # price (y) and quantity (x) intercept of grey demand curve
                b <- p0 - (m * q0p)
                q_int_grey <- -(b / m)

                # green demand represents a rotation of the demand curve about the quantity intercept
                #    [Sedjo & Swallow 2002](zotero://select/items/0_GGH3Y8UX)
                # green electricity consumers pay a premium of [7-30%](./inputs/market_history.html)
                premium <- runif(1, 1.07, 1.3) * (((m * q0p) + b) / (prop_green * (m * q0p) + b))
                b_green <- premium * b

                # shift green demand curve to account for max market size
                q_int_green <- max(prop_green * q_int_grey, 1e-10)

                return(function(q) {
                            p_grey=  nafill(approx(c(0, q_int_grey),  c(b,        0), q)$y, fill=0)
                            p_green= nafill(approx(c(0, q_int_green), c(b_green,  0), q)$y, fill=0)

                            return(data.table(q, "p_grey"= if (prop_green==1) 0 else p_grey,
                                                "p_green"= if (prop_green==0) 0 else p_green))
                })
            })
    )$new(historical_market=na.omit(historical_market_data[, .SD, keyby=.(year, month)]))


# generate validation report for this initialization
cat("Writing validation report\n")
rmarkdown::render("flaringABM_validation_init.Rmd", output_format="html_document",
                output_file=sprintf("%s/outputs/validation/init_%s_%s.html",
                        ifelse(Sys.getenv("WORK")=="", ".", paste0(Sys.getenv("WORK"),"/flaringABM")), jobID, Run),
                intermediates_dir=sprintf("./outputs/validation/init_%s_%s", jobID, Run), quiet=TRUE)
unlink(sprintf("./outputs/validation/init_%s_%s", jobID, Run), recursive=TRUE)

# done
cat("Cleaning up\n\t")
rm(wells, leases_emp, ID, market_shares, rem_capacity, historical_market_data)
gc()

cat(gsub("Time difference of", "Initialization complete in", capture.output(Sys.time() - init_time)), "\n")
